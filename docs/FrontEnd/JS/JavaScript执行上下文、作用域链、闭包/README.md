---
title: JavaScript执行上下文、作用域链、闭包
date: 2020-07-09 09:15:00
tags: [JS基础, 执行上下文, 作用域链, 闭包]
categories: JS
---

# JavaScript 执行上下文、作用域链、闭包

`标题中的名词其实没有列全,要想理解这些概念,我们最好对比着学习这几个重要概念,包括:作用域,作用域链,上下文,执行上下文,执行栈,闭包`

## 作用域(Scope)

定义: 变量,函数或者对象的可访问范围,控制变量,函数,对象的可见性和生命周期.在 js 中,作用域分为全局作用域,函数作用域和块级作用域(ES6 新增 let,const).

JS 采用静态作用域(词法作用域),在词法分析阶段就确定作用域,变量作用域由定义时决定而不是执行时决定.

全局作用域: 在代码中的任何地方都能访问到的对象拥有全局作用域.

1. 没有使用 var 声明的变量具有全局作用域,称为全局变量
2. window 的所有属性具有全局作用域
3. 最外层函数体外声明的变量也具有全局作用域

函数作用域(局部作用域): 只在函数内部可以访问到的变量拥有局部作用域,局部变量优先级高于全局变量.

1. 函数体内部使用 var 声明的变量具有局部作用域,称为局部变量
2. 函数参数具有局部作用域

块级作用域: 使用 let 和 const 关键字声明的变量,具有块级作用域

eg.

```javaScript
var a=3; // 全局变量
function aa(b) {
    c=2; // 没有使用var声明,全局变量
    var d=5; // aa函数局部变量
    function bb() {
        var e=d; // bb函数可以访问父作用域aa的局部变量
        for(var f=0;f<3;f++){
            console.log(f);
        }
        for(let g=6;g<9;g++){
            console.log(g);
        }
        console.log(f); // var声明的f属于bb函数的局部变量
        console.log(g); // g使用let声明,拥有for循环块级作用域,外部不能访问
    }
    bb();
}
aa(1);
console.log(c); // 全局变量c
```

## 作用域链

在函数作用域中查找某个变量时,会在当前作用域的变量对象中查找,如果没找到,会从父级作用域查找,一直找到全局作用域.函数有一个内部属性`[[scope]]`,当函数创建时,会保存所有父变量到这个属性中.`作用域链和原型链有很多相似之处`.

## 上下文(context)

定义: 用来指定代码中某些特定部分的 this 值.可以通过 call(),apply(),bind(),箭头函数改变上下文.在浏览器中,全局作用域的上下文始终是 window 对象,在 Node.js 中全局作用域的上下文始终是 Global 对象.

上下文原则: `this永远指向最后调用它的那个对象`

## 执行上下文

定义: 当前 JS 代码被解析和执行时所处的环境

1. 全局执行上下文: 不在任何函数中的代码都位于全局执行上下文中,一个程序只能存在一个全局执行上下文
2. 函数执行上下文: 每次调用函数时,都会为该函数创建一个新的执行上下文,可以存在多个函数执行上下文
3. Eval 函数执行上下文: 运行在 eval 函数中的代码的执行上下文

## 执行栈

执行栈又称为调用栈,具有先进后出,后进先出的特点,用于存储在代码执行期间创建的所有上下文.

当 JS 引擎首次读取脚本时,会先创建全局执行上下文并推入执行栈,每当发生一个函数调用,就创建一个执行上下文并推入栈顶,JS 引擎会运行栈顶的函数,在函数运行完成后,其执行上下文会从栈中弹出,上下文控制权将移到当前执行栈的下一个(栈顶)执行上下文.

执行上下文在执行过程中分两个阶段:

1. 创建阶段: 绑定 this -> 创建词法环境 -> 创建变量环境
2. 执行阶段: 变量赋值,执行代码

## 总结

从上面的概念学习我们可以发现:

JS 作为一门解释型语言,执行时分为两个步骤:解释和执行.

在解释阶段,JS 引擎进行词法分析,语法分析,明确作用域规则.
在执行阶段,JS 引擎创建执行上下文,执行函数代码,垃圾回收.

`执行上下文在运行时确定,随时可能改变;作用域在定义时就确定,且不会改变`

## 闭包

定义: 有权访问另一个函数作用域中的变量的函数.创建闭包的常见方式就是在一个主函数内部创建并返回另一个函数,通过返回的函数去获取主函数内部的局部变量.

```JavaScript
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
var foo = checkscope();
foo();
```

上面的代码就是一个闭包的演示,在 checkscope 函数执行完成后,我们依然可以获取其中定义的 scope 参数.

那么,这究竟是什么原因呢?

其实,还是要从我们前面提到的作用域链说起,f 函数内部维护了一个作用域链

```
fContext = { Scope: [AO, checkscopeContext.AO, globalContext.VO]} // AO表示当前函数执行上下文活动对象, VO表示全局作用域变量对象
```

f 函数中能够访问到 checkscope 函数中定义的 scope 变量就是通过这个作用域链.
在 checkscope 函数执行完成后,执行栈弹出执行上下文,垃圾回收开始 GC,但是由于存在这样一个内部引用,checkscopeContext.AO 并不会被销毁掉,从而实现了闭包.

### 闭包必刷题

```JavaScript
var data = [];
for (var i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}
data[0]();
data[1]();
data[2]();
```

上面的代码最终输出为 3,3,3. 对比一下下面的代码

```JavaScript
var data = [];
for (var i = 0; i < 3; i++) {
  data[i] = (function (i) {
        return function(){
            console.log(i);
        }
  })(i);
}
data[0]();
data[1]();
data[2]();
```

我们使用立即执行函数为`data[0],data[1],data[2]`创建了三个闭包函数,各个闭包函数中都使用了立即执行函数的参数 i,所以此时输出 0,1,2

我们再看一段代码

```JavaScript
var data = [];
for (let i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}
data[0]();
data[1]();
data[2]();
```

我们将循环中的 i 变量声明改为使用 let,此时输出为 0,1,2.这又是为什么呢?

其实这个时候 i 变量拥有块级作用域,每一次循环,函数获取到的都是当前的变量 i,不像上面的代码,使用 var 声明,i 变量拥有全局作用域,所有循环中函数共享的是同一个变量 i.相当于在 for 循环中使用 let,每次循环都都重新创建了变量 i 的副本绑定到函数中去了.

由于闭包需要通过作用域链保存已经销毁的函数中的变量,所以闭包函数会比一般函数占用更大的空间,需要谨慎使用.
